## &取内存地址操作符号

1. 只能对变量取地址

## 指针
```

int i;
int* p = &i;
int* p, q; // q 是一个普通变量
int *P, q; // q 是一个普通变量
```

## 指针的用途

1. 通过指针接受多个返回结果
2. 函数返回运算状态，结果通过指针带回

## 数组作为参数，会将数组的指针(内存地址)传递给函数 - demo3
1. 数组变量本身表达地址
2. 取int变量的地址需要 &+变量，数组则不用
3. 数组单元表达的是变量 需要用&取地址
4. 数组a的地址 a==&a[0]
    - *a = 12; // 会改变数组a[0]的值为12；
5. []运算符可以对指针变量使用; // 指针变量[0] == *p;
```
int main = 2;
int *p = &main; // p == 内存地址， *p == 2
int x = p[0]; // p[0] == *p;
```
6. 数组之间不能相互赋值
```
int b[]; -> const int * const b; // 数组变量相当于一个常量指针 不能相互赋值
```

## 指针和const
1. 指针和指针指向的value 都可以是const
```
int * const q = &i; // q is const 
*q = 22; // ok
q++;  // error
```
2. 
```
const int *p = &i; 
// 不能通过*p 修改i的value;
*p = 23; // error (*p)是const
i = 23; // ok
p = &j; // ok
```

3. const在*前，则*p不能改，const在*后，则p不能修改
```
int i;
// p1,p2 表达式等价
const int *p1 = &i; //
int const* p2 = &i; // 
int *const p3 = &i; // 
```
4. 总是可以将一个非const的值转换为const
    - 当传递的参数比地址大的时候，常用手段。既可以用较少的字节传递值给参数，又能避免函数对外面变量的修改。
```
// 函数内不会修改指针p所指的值
void f(const int *p); 
```
5. const数组
```
const int a[] = {1, 2, 3, 4}; // 表明数组的每一项都是const 之后不能改变

int sum(const int a[]); // 将参数设置为const 可以保护数组不受破坏

```


## 指针运算 demo4.c
当指针+1，指的是指针指向下一个单元 对于不同的数据类型，内存地址增加的数量不同 

## 动态内存分配
